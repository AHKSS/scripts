local function isEgg(itemName)
    return string.find(itemName:lower(), "egg") ~= nil
end

local function getLuckValue(rift, maxRetries)
    maxRetries = maxRetries or 3
    local retryCount = 0
    
    local function tryGetLuck()
        if not rift or not rift:FindFirstChild("Display") then return nil end
        
        local surfaceGui = rift.Display:FindFirstChild("SurfaceGui")
        if not surfaceGui then return nil end
        
        local icon = surfaceGui:FindFirstChild("Icon")
        if not icon then return nil end
        
        local luckLabel = icon:FindFirstChild("Luck")
        if not luckLabel then return nil end
        
        return luckLabel.Text
    end
    
    local luckValue = tryGetLuck()
    
    while luckValue == nil and retryCount < maxRetries do
        retryCount = retryCount + 1
        wait(1) 
        luckValue = tryGetLuck()
    end
    
    return luckValue
end

local notifiedRifts = {}

local function isWantedItem(itemName)
    local lowerName = itemName:lower()
    for _, wantedItem in pairs(Shared.Settings.WantedItems) do
        if lowerName == wantedItem:lower() then
            return true
        end
    end
    return false
end

local function sendWebhookNotification(rift)
    if not Shared.Settings.EnableNotifications or Shared.Settings.WebhookUrl == "" then
        return
    end
    
    if notifiedRifts[rift] then
        return
    end
    
    notifiedRifts[rift] = true
    
    print("Sending webhook notification for: " .. rift.Name)
    
    local HttpService = game:GetService("HttpService")
    local http_request = (syn and syn.request) or (http and http.request) or http_request or (fluxus and fluxus.request) or request

    local luckValue = "Unknown"
    if isEgg(rift.Name) then
        local luck = getLuckValue(rift)
        if luck then
            luckValue = luck
        end
    end

     local fields = {
        {
            name = "<:emoji:1360897783644815573> Item Name: " .. tostring(rift.Name),
            value = "",
            inline = false
        },
        {
            name = "üìè Height: ".. tostring(math.floor(rift.WorldPivot.Position.Y)) .. "m",
            value = "",
            inline = false
        },
        {
            name = "<:emoji:1328013975601811679> When: <t:" .. os.time() .. ":R>",
            value = "",
            inline = false
        }
    }
    
    if isEgg(rift.Name) then
        table.insert(fields, {
            name = "üçÄ Luck: " .. luckValue,
            value = "",
            inline = false
        })
    end
    
    table.insert(fields, {
        name = "‚è≥ Despawn Time: " .. (rift:GetAttribute("DespawnAt") and ("<t:" .. math.floor(rift:GetAttribute("DespawnAt")) .. ":R>") or "Unknown"),
        value = "",
        inline = false
    })
    
    table.insert(fields, {
        name = "üåê **Click to Join: https://www.roblox.com/games/start?placeId="..game.PlaceId.."&gameInstanceId="..game.JobId.."**",
        value = "",
        inline = false
    })
    
    local data = {
        content = "@here",
        embeds = {
            {
                title = "WH Notifier",
                description = "",
                color = 65280, 
                fields = fields,
                timestamp = DateTime.now():ToIsoDate()
            }
        }
    }
    
    local success, response = pcall(function()
        return http_request({
            Url = Shared.Settings.WebhookUrl,
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json"
            },
            Body = HttpService:JSONEncode(data)
        })
    end)
    
    if success then
        print("Webhook sent successfully")
    else
        warn("Failed to send webhook: " .. tostring(response))
    end
end

local function checkExistingRifts()
    local rifts = workspace.Rendered.Rifts:GetChildren()
    for _, rift in pairs(rifts) do
        if isWantedItem(rift.Name) then
            print("Found existing wanted item: " .. rift.Name)
            sendWebhookNotification(rift)
        end
    end
end

-- Function to handle when a new rift is added
local function onRiftAdded(rift)
    if isWantedItem(rift.Name) then
        print("Found new wanted item: " .. rift.Name)
        sendWebhookNotification(rift)
    end
end

-- Function to handle when a rift is removed
local function onRiftRemoved(rift)
    if notifiedRifts[rift] then
        notifiedRifts[rift] = nil
    end
end

local monitoringConnection = nil
local removedConnection = nil

local function startMonitoring()
    -- Always clean up existing connections first
    if monitoringConnection then
        monitoringConnection:Disconnect()
        monitoringConnection = nil
    end
    
    if removedConnection then
        removedConnection:Disconnect()
        removedConnection = nil
    end
    
    -- Only proceed if notifications are enabled
    if not Shared.Settings.EnableNotifications then
        return
    end
    
    checkExistingRifts()
    
    monitoringConnection = workspace.Rendered.Rifts.ChildAdded:Connect(onRiftAdded)
    removedConnection = workspace.Rendered.Rifts.ChildRemoved:Connect(onRiftRemoved)
end

-- Initial start
startMonitoring()

-- Monitoring for settings changes
spawn(function()
    local lastState = Shared.Settings.EnableNotifications
    
    while wait(1) do
        if lastState ~= Shared.Settings.EnableNotifications then
            lastState = Shared.Settings.EnableNotifications
            
            if lastState then
                print("Notifications enabled, starting monitoring")
                startMonitoring()
            else
                print("Notifications disabled, stopping monitoring")
                if monitoringConnection then
                    monitoringConnection:Disconnect()
                    monitoringConnection = nil
                end
                
                if removedConnection then
                    removedConnection:Disconnect()
                    removedConnection = nil
                end
            end
        end
    end
end)
